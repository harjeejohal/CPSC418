Name: Harjee Johal
UCID: 30000668
CPSC 418 - Assignment 2

I believe that my choices of using os.urandom() to generate the salt, and the usage of secrets.randbits() and
secrets.randbelow() are valid. The reason is because none of these methods are pseudo-random (deterministic). In a pseudo-random
number generator, given a seed, every execution of that generator will generate the same sequence of numbers for that
seed, regardless of how many times. However, the same cannot be said for the methods that I used. The methods that I
have used in my implementation are based upon algorithms that use multiple, high-quality sources of randomness from the OS as the basis
to generate the random strings, rather than a simple seed, meaning that a finding replicable process to generate a certain
sequence of numbers is not feasible. Therefore, I feel that these methods are reasonable choices, since the process
for generating the values isn't deterministic.

Here is the citation indicating that the numbers generated by the secrets module aren't pseudo-random/ deterministic:
https://docs.python.org/3/library/secrets.html

Here is the citation indicating that the byte values generated by the os.urandom method aren't pseudo-random/ deterministic:
https://docs.python.org/3/library/os.html#os.urandom


For the procedure to generate N, I first generate Sophie-Germain prime candidates. Using secrets.randbits(), I generate
random 511-bit strings. I OR this string with 0b1, and with (0b1 << 511) | 1, which ensures two things. The first OR
ensures that the number is random, since there's no point in checking any even numbers for primality (save for 2, which
is far too small anyway). The second OR ensures that the most significant bit truly is 1. The random generator could
have set the most significant bit to 0, which could end up netting us an N value that's actually smaller than 512 bits.
Next, this number is tested for primality. If it's not prime, the process is restarted. If it's prime, I then multiply this
number by 2, and then add 1 to the product. I then check this number for primality. If it's not prime, we once again start 
the procedure from the beginning, and generate a new 511-bit number. If it's prime, this is used as the candidate
value for N. Next, to find the primitive root g of N, I ran a loop over the numbers in the range [1, N-1]. For each
number in this loop, I performed the following check along the way: g^(N-1/q) != 1 (mod N) for all prime factors q of
N - 1. Since N is of the form 2 * prime + 1, that means N - 1 = 2 * prime. Therefore, the only prime factors of N - 1
that need to be tested are 2 and the original prime that was used to generate N. If the candidate primitive root passes
the check for both prime factors, then it's used as g, and our candidate value of N becomes the value we use for N. 
Else, if no primitive root can be found, the whole process is started again from the top, and another 511-bit value is generated.


The files included are: 
	- Server.py, which contains all of the logic for the server-side during registration/authentication
	- Client.py, which contains all of the logic for the client-side during registration/authentication


The problem is solved in full, and passed the auto-grader.


There are no known bugs.
