#!/usr/bin/env python3

import sys
import socket
import os
import secrets
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes

# Name: Harjee Johal
# UCID: 30000668

HOSTNAME = '127.0.4.18'
PORT = 31802


# I saw a message on Piazza that said print statements should be flushed, so I replaced my print
# statements with calls to this
def flush_output(message_contents):
    print(message_contents, flush=True)


# Calculates M2 as H(A || M1 || K_Client), where H is the SHA-256 hash
def calculate_m2(big_a, m1, client_key):
    big_a_bytes = big_a.to_bytes(64, byteorder='big')
    key_bytes = client_key.to_bytes(64, byteorder='big')
    all_bytes = big_a_bytes + m1 + key_bytes

    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(all_bytes)

    return digest.finalize()


# Generates a value of M1 to be used for authentication with the server. It's generated as H(A || B || K_Client),
# where H is the SHA-256 hash
def generate_m1(big_a, big_b, client_key):
    a_bytes = big_a.to_bytes(64, byteorder='big')
    b_bytes = big_b.to_bytes(64, byteorder='big')
    client_key_bytes = client_key.to_bytes(64, byteorder='big')
    all_bytes = a_bytes + b_bytes + client_key_bytes

    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(all_bytes)

    return digest.finalize()


"""
Calculates the client key as K_Client = (B - kv)^(a + ux) (mod N). Within this method, I also generate u and k first.
u is generated as H(A || B) (mod N), and k is generated as H(N || g) (mod N). In both cases, H is the SHA-256 hash.
"""
def calculate_client_key(big_a, big_b, x, v, a, n_prime, primitive_root):
    a_bytes = big_a.to_bytes(64, byteorder='big')
    b_bytes = big_b.to_bytes(64, byteorder='big')
    all_bytes = a_bytes + b_bytes

    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(all_bytes)
    hashed_val = digest.finalize()
    hash_num = int.from_bytes(hashed_val, 'big')
    u = hash_num % n_prime

    flush_output('Client: u = %d' % u)

    n_bytes = n_prime.to_bytes(64, 'big')
    root_bytes = primitive_root.to_bytes(64, 'big')
    all_bytes = n_bytes + root_bytes

    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(all_bytes)
    hashed_val = digest.finalize()
    k = int.from_bytes(hashed_val, 'big')

    flush_output('Client: k = %d' % k)

    base = big_b - k * v
    exponent = u * x + a

    return u, k, int(pow(base, exponent, n_prime))


# This is used to get the password and username from the user during registration
def get_user_input():
    print("Username: ")
    username_raw = sys.stdin.readline().strip()
    # encode it as bytes, and record the length
    username = username_raw.encode('utf-8')

    print("Password: ")
    pw_raw = sys.stdin.readline().strip()
    # encode it as bytes, and record the length
    pw = pw_raw.encode('utf-8')

    return username, pw


# Calculates v as g^x (mod N). However, this method first calculates x. x is calculated as H(s || p), where
# is the 16-byte salt generated by the user, and p is the users password. H is the SHA-256 hash function.
def calculate_key_with_hash(salt, password, n_prime, primitive_root):
    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(salt)
    digest.update(password)
    hashed_val = digest.finalize()
    hashed_int = int.from_bytes(hashed_val, 'big')

    return hashed_int, pow(primitive_root, hashed_int, n_prime)


"""
This method is used during the registration phase. The client receives N and g from the server, first.
Next, the client generates a value of v, which is sends to the server, along with a registration flag 'r', the
length of the user's username, the username itself, and v.
"""
def setup_server_connection(user, password):
    salt = os.urandom(16)
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOSTNAME, PORT))
        n_prime = s.recv(64)
        n_prime = int.from_bytes(n_prime, 'big')

        primitive_root = s.recv(64)
        primitive_root = int.from_bytes(primitive_root, 'big')

        x, v = calculate_key_with_hash(salt, password, n_prime, primitive_root)

        flush_output("Client: Sending 'r' <%s>" % bytes('r', 'utf-8').hex())
        s.sendall(bytes('r', 'utf-8'))

        username_size_bytes = len(user).to_bytes(4, byteorder='big')
        flush_output('Client: Sending |I| <%s>' % username_size_bytes.hex())
        s.sendall(username_size_bytes)

        flush_output('Client: Sending I <%s>' % user.hex())
        s.sendall(user)

        flush_output('Client: s = <%s>' % salt.hex())
        flush_output('Client: Sending s <%s>' % salt.hex())
        s.sendall(salt)

        v_bytes = v.to_bytes(64, 'big')
        flush_output('Client: v = %d' % v)
        flush_output('Client: Sending v <%s>' % v_bytes.hex())
        s.sendall(v_bytes)

        flush_output('Client: Registration successful')


# This method computes A as A = g^a (mod N), where a is a randomly generated integer such that 0 <= a <= N - 2
def compute_big_a(n_prime, primitive_root):
    a = secrets.randbelow(n_prime - 1)
    big_a = pow(primitive_root, a, n_prime)

    flush_output('Client: a = %d' % a)

    flush_output('Client: A = %d' % big_a)

    return a, big_a


"""
This method is used during the authentication process. The client opens up a new socket connection to the server.
Immedidately upon connection, the server sends N and g to the client again. The client then computes a value for A.
The client then sends a flag 'p', the length of the user's username, the username itself, and A. Next, the client
receives the 16-byte salt from the server, along with the value of B that the server generated. The server uses this
information to generate its client key. The client then generates a value for M1 and sends it to the server.
If this value of M1 matches the value generated by the server, then the client generates a value of M2, which it matches
with the value of M2 it receives from the server. If the values match, then the client echoes a successful connection.
Otherwise, the client echoes an unsuccessful connection. The socket is then closed.
"""
def negotiation_with_server(username, password):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((HOSTNAME, PORT))

        n_prime = s.recv(64)
        n_prime = int.from_bytes(n_prime, 'big')

        primitive_root = s.recv(64)
        primitive_root = int.from_bytes(primitive_root, 'big')

        a, big_a = compute_big_a(n_prime, primitive_root)

        flush_output('Client: N = %d' % n_prime)
        flush_output('Client: g = %d' % primitive_root)

        flush_output("Client: Sending 'p' <%s>" % bytes('p', 'utf-8').hex())
        s.sendall(bytes('p', 'utf-8'))

        username_size_bytes = len(username).to_bytes(4, byteorder='big')
        flush_output('Client: Sending |I| <%s>' % username_size_bytes.hex())
        s.sendall(username_size_bytes)

        flush_output('Client: Sending I <%s>' % username.hex())
        s.sendall(username)

        big_a_bytes = big_a.to_bytes(64, byteorder='big')
        flush_output('Client: Sending A <%s>' % big_a_bytes.hex())
        s.sendall(big_a_bytes)

        salt = s.recv(16)
        flush_output('Client: s = <%s>' % salt.hex())

        big_b_raw = s.recv(64)
        big_b = int.from_bytes(big_b_raw, 'big')
        flush_output('Client: B = %d' % big_b)

        # generated outside of the calculate_client_key() method, so that it doesn't get too large
        x, v = calculate_key_with_hash(salt, password, n_prime, primitive_root)
        u, k, client_key = calculate_client_key(big_a, big_b, x, v, a, n_prime, primitive_root)
        del x
        flush_output('Client: k_client = %d' % client_key)

        m1 = generate_m1(big_a, big_b, client_key)
        flush_output('Client: M1 = <%s>' % m1.hex())
        flush_output('Client: Sending M1 <%s>' % m1.hex())
        s.sendall(m1)

        m2 = calculate_m2(big_a, m1, client_key)
        flush_output('Client: M2 = <%s>' % m2.hex())

        try:
            m2_server = s.recv(32)
            if m2 == m2_server:
                flush_output('Client: Negotiation successful')
            else:
                flush_output('Client: Negotiation unsuccessful')
        except IOError:
            flush_output('Client: Negotiation unsuccessful')


# My "main" method. Calls the registration method, and then the authentication method
def init():
    username, password = get_user_input()
    setup_server_connection(username, password)
    negotiation_with_server(username, password)


init()
