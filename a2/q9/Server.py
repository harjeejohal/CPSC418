#!/usr/bin/env python3
from sympy import isprime
import socket
import secrets
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes

# Name: Harjee Johal
# UCID: 30000668
# CPSC 418 - Assignment 2

# Used for the socket
HOSTNAME = '127.0.4.18'
PORT = 31802


# I saw a message on Piazza that said print statements should be flushed, so I replaced my print
# statements with calls to this
def flush_output(message_contents):
    print(message_contents, flush=True)


# Calculates the value of M2 as H(A || M_1 || B), where H is a SHA-256 hash
def calculate_m2(big_a, m1_server, server_key):
    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(big_a.to_bytes(64, byteorder='big'))
    digest.update(m1_server)
    digest.update(server_key.to_bytes(64, byteorder='big'))

    return digest.finalize()


# Calculates M1 as H(A || B || K_Server), where H is a SHA-256 hash
def generate_m1(big_a, big_b, server_key):
    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(big_a.to_bytes(64, byteorder='big'))
    digest.update(big_b.to_bytes(64, byteorder='big'))
    digest.update(server_key.to_bytes(64, byteorder='big'))

    return digest.finalize()


"""
Calculates B as B = kv + g^b (mod N). In the Protocol description, it says to pick a value of b such
that 0 <= b <= N - 1. However, later on it's stated that the range of values for b must be between
0 and N - 2 (inclusive). Therefore, I opted for the smaller of these two ranges, just to be safe
"""
def calculate_big_b(n_prime, primitive_root, v):

    b = secrets.randbelow(n_prime - 1)

    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(n_prime.to_bytes(64, 'big'))
    digest.update(primitive_root.to_bytes(64, 'big'))
    hashed_val = digest.finalize()

    k = int.from_bytes(hashed_val, 'big')
    summation = pow(primitive_root, b, n_prime) + k * v

    big_b = summation % n_prime

    flush_output('Server: b = %d' % b)

    flush_output('Server: k = %d' % k)

    flush_output('Server: B = %d' % big_b)

    return big_b, b


# Computes u as H(A || B) mod N, where H is a SHA-256 hash
def compute_u(big_a, big_b, n_prime):
    a_bytes = big_a.to_bytes(64, byteorder='big')
    b_bytes = big_b.to_bytes(64, byteorder='big')
    all_bytes = a_bytes + b_bytes

    digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
    digest.update(all_bytes)
    hashed_val = digest.finalize()

    hash_num = int.from_bytes(hashed_val, 'big')
    return hash_num % n_prime


# Computes the server key as (A(v^u))^b (mod N)
def compute_server_key(big_a, v, u, b, n_prime):
    u_b = u * b
    base_one = pow(big_a, b, n_prime)
    base_two = pow(v, u_b, n_prime)
    return (base_one * base_two) % n_prime


"""
This method handles both registration and authentication
It sends out N and g to the client during registration.
In return, the client sends the registration flag, length of username,
username, the salt generated by the client, and the value of v calculated by the client.
The server then stores these credentials to be used during the client's authentication.

Next, during authentication, the server once again sends N and g upon the socket connection
being accepted. B is also calculated using the randomly-generated b. The client  once again sends
a flag ('p' this time), the length of the username, the username itself, and the value of A generated client-side.
The server then sends its value of B to the client, and also generates the server key. After receiving M1 from the 
client, thee server then generates its own version of M1 and compares the two. If they match, then the server echoes 
success and generates a value for M2 and then sends it to the M2. Else, it echoes failure.
"""
def setup_client_connection(n_prime, primitive_root):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as soc:
        flush_output('Server is running')
        flush_output('Server: N = %d' % n_prime)
        flush_output('Server: g = %d' % primitive_root)
        soc.bind((HOSTNAME, PORT))
        soc.listen()
        while True:
            conn, addr = soc.accept()
            with conn:
                bytes_prime = n_prime.to_bytes(64, byteorder='big')
                bytes_root = primitive_root.to_bytes(64, byteorder='big')
                flush_output('Server: Sending N <%s>' % bytes_prime.hex())
                flush_output('Server: Sending g <%s>' % bytes_root.hex())
                conn.sendall(bytes_prime)
                conn.sendall(bytes_root)

                r = conn.recv(1).decode('utf-8')
                i_size = int.from_bytes(conn.recv(4), 'big')

                i = conn.recv(i_size).decode('utf-8')
                flush_output("Server: I = '%s'" % i)

                salt = conn.recv(16)
                flush_output("Server: s = <%s>" % salt.hex())

                v_raw = conn.recv(64)
                v = int.from_bytes(v_raw, 'big')
                flush_output('Server: v = %d' % v)

                flush_output('Server: Registration successful')

            conn, addr = soc.accept()
            with conn:
                bytes_prime = n_prime.to_bytes(64, byteorder='big')
                bytes_root = primitive_root.to_bytes(64, byteorder='big')
                flush_output('Server: Sending N <%s>' % bytes_prime.hex())
                flush_output('Server: Sending g <%s>' % bytes_root.hex())
                conn.sendall(bytes_prime)
                conn.sendall(bytes_root)

                big_b, b = calculate_big_b(n_prime, primitive_root, v)
                data = conn.recv(1).decode('utf-8')

                username_size = int.from_bytes(conn.recv(4), 'big')
                username = conn.recv(username_size).decode('utf-8')
                big_a = int.from_bytes(conn.recv(64), 'big')

                flush_output("Server: I = '%s'" % username)
                flush_output("Server: A = %d" % big_a)

                flush_output('Server: Sending s <%s>' % salt.hex())
                conn.sendall(salt)

                big_b_bytes = big_b.to_bytes(64, byteorder='big')
                flush_output('Server: Sending B <%s>' % big_b_bytes.hex())
                conn.sendall(big_b_bytes)

                u = compute_u(big_a, big_b, n_prime)
                flush_output('Server: u = %d' % u)

                server_key = compute_server_key(big_a, v, u, b, n_prime)
                flush_output('Server: k_server = %d' % server_key)

                m1 = conn.recv(32)

                flush_output('Server: M1 = <%s>' % m1.hex())

                m1_server = generate_m1(big_a, big_b, server_key)

                if m1 == m1_server:
                    flush_output('Server: Negotiation successful')

                    m2 = calculate_m2(big_a, m1_server, server_key)

                    flush_output('Server: M2 = <%s>' % m2.hex())
                    flush_output('Server: Sending M2 <%s>' % m2.hex())
                    conn.sendall(m2)
                else:
                    flush_output('Server: Negotiation unsuccessful')


"""
According to the notes, one of the primitive root tests is to check if the candidate g satisfies:
g^[(N-1)/q] != 1 (mod N) for all prime factors q of (N - 1). Since N is generated using a Sophie-Germain prime,
that means that N = 2q + 1, which also means that N - 1 = 2q. Therefore, there are only two prime factors that 
need to be tested: 2, and the Sophie-Germain prime that was used to generate N, q.
"""
def find_primitive_root(sophie_prime, prime):
    for num in range(1, prime):
        if pow(num, 2, prime) != 1 and pow(num, sophie_prime, prime) != 1:
            return num

    return -1


"""
This method is used to generate N and g. It first generates Sophie-Germain prime candidates q, and then uses those
to generate safe prime candidates N using N = 2q + 1. If N is prime, then a primitive root g determined. If no g can be
found, then the process starts anew. Otherwise, both N and g are returned.
"""
def initial_values():
    n_prime_not_found = True
    while n_prime_not_found:
        test_prime = secrets.randbits(511)
        # Makes sure that the number is odd and that the 511th bit isn't randomly set to 0
        # I saw someone on Piazza trying to do this using BitArray, and thought it might be
        # better with bit-shifting
        test_prime |= 1
        test_prime |= (1 << 510)

        # If this number is prime, it's used as a candidate Sophie-Germain prime
        is_prime = isprime(test_prime)

        if is_prime:
            n_prime = 2 * test_prime + 1

            # If 2(test_prime) + 1 is also prime, then test_prime is a Sophie-Germain prime, and n_prime
            # is what's know as a "safe prime"
            if isprime(n_prime):
                primitive_root = find_primitive_root(test_prime, n_prime)

                if primitive_root == -1:
                    continue
                else:
                    return n_prime, primitive_root


# This is essentially my "main" method
def init():
    n_prime, primitive_root = initial_values()
    setup_client_connection(n_prime, primitive_root)


init()
